./admin_gateway/audit.py:24:        core_api_key: Optional[str] = None,
./admin_gateway/audit.py:29:        self.core_api_key = core_api_key
./admin_gateway/audit.py:49:        if self.core_base_url and self.forward_enabled and self.core_api_key:
./admin_gateway/audit.py:53:        if not self.core_base_url or not self.core_api_key:
./admin_gateway/audit.py:61:                headers={"X-API-Key": self.core_api_key},
./admin_gateway/audit.py:67:        redacted = self._redact_secrets(event)
./admin_gateway/audit.py:92:            "api_key",
./admin_gateway/audit.py:94:            "client_secret",
./admin_gateway/audit.py:95:            "client-secret",
./admin_gateway/audit.py:96:            "access_token",
./admin_gateway/audit.py:97:            "refresh_token",
./admin_gateway/audit.py:98:            "id_token",
./admin_gateway/audit.py:99:            "token",
./admin_gateway/audit.py:100:            "secret",
./admin_gateway/audit.py:104:            fragment in normalized for fragment in ("token", "secret", "api-key")
./admin_gateway/audit.py:108:    def _redact_secrets(cls, value: Any) -> Any:
./admin_gateway/audit.py:115:                    redacted[key] = cls._redact_secrets(item)
./admin_gateway/audit.py:118:            return [cls._redact_secrets(item) for item in value]
./admin_gateway/auth/config.py:21:        FG_OIDC_CLIENT_SECRET: OAuth client secret
./admin_gateway/auth/config.py:33:    oidc_client_secret: Optional[str] = None
./admin_gateway/auth/config.py:43:    session_secret: str = field(default_factory=lambda: os.urandom(32).hex())
./admin_gateway/auth/config.py:48:    csrf_cookie_name: str = "fg_csrf_token"
./admin_gateway/auth/config.py:67:            and self.oidc_client_secret
./admin_gateway/auth/config.py:115:            self.oidc_client_secret,
./admin_gateway/auth/config.py:124:            if not self.oidc_client_secret:
./admin_gateway/auth/config.py:161:        oidc_client_secret=os.getenv("FG_OIDC_CLIENT_SECRET"),
./admin_gateway/auth/config.py:165:        session_secret=os.getenv("FG_SESSION_SECRET", os.urandom(32).hex()),
./admin_gateway/auth/csrf.py:11:import secrets
./admin_gateway/auth/csrf.py:34:    The token is:
./admin_gateway/auth/csrf.py:49:        self._secret = self.config.session_secret.encode()
./admin_gateway/auth/csrf.py:51:    def _generate_token(self) -> str:
./admin_gateway/auth/csrf.py:52:        """Generate a new CSRF token.
./admin_gateway/auth/csrf.py:56:        random_part = secrets.token_urlsafe(24)
./admin_gateway/auth/csrf.py:59:        signature = hmac.new(self._secret, data, hashlib.sha256).hexdigest()[:16]
./admin_gateway/auth/csrf.py:62:    def _validate_token(self, token: str) -> bool:
./admin_gateway/auth/csrf.py:63:        """Validate a CSRF token.
./admin_gateway/auth/csrf.py:71:            parts = token.split(".")
./admin_gateway/auth/csrf.py:79:            expected = hmac.new(self._secret, data, hashlib.sha256).hexdigest()[:16]
./admin_gateway/auth/csrf.py:81:                log.warning("CSRF token signature mismatch")
./admin_gateway/auth/csrf.py:87:                log.warning("CSRF token expired")
./admin_gateway/auth/csrf.py:93:            log.warning("CSRF token validation error: %s", e)
./admin_gateway/auth/csrf.py:96:    def get_token_from_request(
./admin_gateway/auth/csrf.py:99:        """Get CSRF token from cookie and header.
./admin_gateway/auth/csrf.py:102:            Tuple of (cookie_token, header_token)
./admin_gateway/auth/csrf.py:104:        cookie_token = request.cookies.get(self.config.csrf_cookie_name)
./admin_gateway/auth/csrf.py:105:        header_token = request.headers.get(self.config.csrf_header_name)
./admin_gateway/auth/csrf.py:106:        return cookie_token, header_token
./admin_gateway/auth/csrf.py:124:        cookie_token, header_token = self.get_token_from_request(request)
./admin_gateway/auth/csrf.py:126:        # Must have both tokens
./admin_gateway/auth/csrf.py:127:        if not cookie_token:
./admin_gateway/auth/csrf.py:131:                detail="CSRF token missing from cookie",
./admin_gateway/auth/csrf.py:134:        if not header_token:
./admin_gateway/auth/csrf.py:138:                detail=f"CSRF token missing from {self.config.csrf_header_name} header",
./admin_gateway/auth/csrf.py:142:        if not hmac.compare_digest(cookie_token, header_token):
./admin_gateway/auth/csrf.py:143:            log.warning("CSRF token mismatch for %s %s", method, request.url.path)
./admin_gateway/auth/csrf.py:146:                detail="CSRF token mismatch",
./admin_gateway/auth/csrf.py:149:        # Validate token format and signature
./admin_gateway/auth/csrf.py:150:        if not self._validate_token(cookie_token):
./admin_gateway/auth/csrf.py:151:            log.warning("CSRF token invalid for %s %s", method, request.url.path)
./admin_gateway/auth/csrf.py:154:                detail="CSRF token invalid or expired",
./admin_gateway/auth/csrf.py:157:    def set_token_cookie(self, response: Response, token: Optional[str] = None) -> str:
./admin_gateway/auth/csrf.py:158:        """Set CSRF token cookie on response.
./admin_gateway/auth/csrf.py:162:            token: Token to set (generates new if not provided)
./admin_gateway/auth/csrf.py:165:            The token that was set
./admin_gateway/auth/csrf.py:167:        if token is None:
./admin_gateway/auth/csrf.py:168:            token = self._generate_token()
./admin_gateway/auth/csrf.py:172:            value=token,
./admin_gateway/auth/csrf.py:180:        return token
./admin_gateway/auth/csrf.py:182:    def clear_token_cookie(self, response: Response) -> None:
./admin_gateway/auth/csrf.py:183:        """Clear CSRF token cookie."""
./admin_gateway/auth/dependencies.py:92:    """Verify CSRF token for state-changing requests.
./admin_gateway/auth/oidc.py:11:import secrets
./admin_gateway/auth/oidc.py:31:    token_endpoint: str
./admin_gateway/auth/oidc.py:56:            token_endpoint=config["token_endpoint"],
./admin_gateway/auth/oidc.py:109:        return secrets.token_urlsafe(64)
./admin_gateway/auth/oidc.py:114:        return secrets.base64.urlsafe_b64encode(digest).rstrip(b"=").decode()
./admin_gateway/auth/oidc.py:133:        state = secrets.token_urlsafe(32)
./admin_gateway/auth/oidc.py:134:        nonce = secrets.token_urlsafe(32)
./admin_gateway/auth/oidc.py:205:        """Exchange authorization code for tokens.
./admin_gateway/auth/oidc.py:212:            Token response containing access_token, id_token, etc.
./admin_gateway/auth/oidc.py:216:            httpx.HTTPStatusError: If token exchange fails
./admin_gateway/auth/oidc.py:226:                provider.token_endpoint,
./admin_gateway/auth/oidc.py:232:                    "client_secret": self.config.oidc_client_secret,
./admin_gateway/auth/oidc.py:240:    async def get_userinfo(self, access_token: str) -> dict[str, Any]:
./admin_gateway/auth/oidc.py:244:            access_token: OAuth access token
./admin_gateway/auth/oidc.py:257:                headers={"Authorization": f"Bearer {access_token}"},
./admin_gateway/auth/oidc.py:263:    def parse_id_token_claims(self, id_token: str) -> dict[str, Any]:
./admin_gateway/auth/oidc.py:264:        """Parse claims from ID token (without signature verification).
./admin_gateway/auth/oidc.py:270:            id_token: JWT ID token
./admin_gateway/auth/oidc.py:280:            parts = id_token.split(".")
./admin_gateway/auth/oidc.py:294:            log.warning("Failed to parse ID token: %s", e)
./admin_gateway/auth/oidc.py:306:            claims: OIDC token claims
./admin_gateway/auth/oidc.py:336:    async def create_session_from_tokens(
./admin_gateway/auth/oidc.py:338:        tokens: dict[str, Any],
./admin_gateway/auth/oidc.py:340:        """Create a session from OIDC token response.
./admin_gateway/auth/oidc.py:343:            tokens: Token response from exchange_code
./admin_gateway/auth/oidc.py:348:        # Parse ID token claims
./admin_gateway/auth/oidc.py:349:        id_token = tokens.get("id_token", "")
./admin_gateway/auth/oidc.py:350:        claims = self.parse_id_token_claims(id_token) if id_token else {}
./admin_gateway/auth/oidc.py:353:        access_token = tokens.get("access_token")
./admin_gateway/auth/oidc.py:354:        if access_token:
./admin_gateway/auth/oidc.py:356:                userinfo = await self.get_userinfo(access_token)
./admin_gateway/auth/session.py:13:import secrets
./admin_gateway/auth/session.py:35:        claims: Raw OIDC token claims
./admin_gateway/auth/session.py:50:    session_id: str = field(default_factory=lambda: secrets.token_urlsafe(16))
./admin_gateway/auth/session.py:96:            session_id=data.get("session_id", secrets.token_urlsafe(16)),
./admin_gateway/auth/session.py:110:        self._secret = self.config.session_secret.encode()
./admin_gateway/auth/session.py:114:        return hmac.new(self._secret, data, hashlib.sha256).hexdigest()
./admin_gateway/auth/session.py:225:            claims: OIDC token claims
./admin_gateway/auth/tenant.py:67:    1. allowed_tenants claim from OIDC token
./admin_gateway/auth.py:6:import secrets
./admin_gateway/auth.py:68:def require_session_secret() -> str:
./admin_gateway/auth.py:69:    secret = os.getenv("FG_SESSION_SECRET")
./admin_gateway/auth.py:70:    if secret:
./admin_gateway/auth.py:71:        return secret
./admin_gateway/auth.py:74:    return secrets.token_urlsafe(32)
./admin_gateway/auth.py:172:def ensure_csrf_token(request: Request) -> str:
./admin_gateway/auth.py:173:    token = request.session.get("csrf_token")
./admin_gateway/auth.py:174:    if not token:
./admin_gateway/auth.py:175:        token = secrets.token_urlsafe(32)
./admin_gateway/auth.py:176:        request.session["csrf_token"] = token
./admin_gateway/auth.py:177:    return token
./admin_gateway/auth.py:219:def _parse_scopes(claims: dict, token_scope: Optional[str]) -> list[str]:
./admin_gateway/auth.py:220:    if token_scope:
./admin_gateway/auth.py:221:        return token_scope.split()
./admin_gateway/auth.py:242:    state = secrets.token_urlsafe(24)
./admin_gateway/auth.py:243:    nonce = secrets.token_urlsafe(24)
./admin_gateway/auth.py:257:async def exchange_code_for_tokens(code: str) -> dict:
./admin_gateway/auth.py:260:    client_secret = os.getenv("FG_OIDC_CLIENT_SECRET")
./admin_gateway/auth.py:262:    if not issuer or not client_id or not client_secret or not redirect_uri:
./admin_gateway/auth.py:268:    token_endpoint = config["token_endpoint"]
./admin_gateway/auth.py:274:        "client_secret": client_secret,
./admin_gateway/auth.py:277:        response = await client.post(token_endpoint, data=payload)
./admin_gateway/auth.py:282:async def verify_id_token(id_token: str, nonce: str) -> dict:
./admin_gateway/auth.py:295:        header = jwt.get_unverified_header(id_token)
./admin_gateway/auth.py:301:                status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token"
./admin_gateway/auth.py:304:            id_token,
./admin_gateway/auth.py:312:            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token"
./admin_gateway/auth.py:316:            status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token nonce"
./admin_gateway/auth.py:321:def build_user_from_claims(claims: dict, token_scope: Optional[str]) -> AuthUser:
./admin_gateway/auth.py:322:    scopes = _parse_scopes(claims, token_scope)
./admin_gateway/main.py:72:                core_api_key=os.getenv("AG_CORE_API_KEY"),
./admin_gateway/main.py:117:    session_secret = config.session_secret
./admin_gateway/main.py:120:        secret_key=session_secret,
./admin_gateway/middleware/auth.py:177:            self.csrf.set_token_cookie(response)
./admin_gateway/middleware/csrf.py:21:    """Enforce CSRF tokens on state-changing requests."""
./admin_gateway/routers/admin.py:47:    """CSRF token response."""
./admin_gateway/routers/admin.py:49:    csrf_token: str
./admin_gateway/routers/admin.py:99:def _core_api_key() -> str:
./admin_gateway/routers/admin.py:100:    api_key = (os.getenv("AG_CORE_API_KEY") or "").strip()
./admin_gateway/routers/admin.py:101:    if not api_key:
./admin_gateway/routers/admin.py:106:    return api_key
./admin_gateway/routers/admin.py:119:        "X-API-Key": _core_api_key(),
./admin_gateway/routers/admin.py:152:        "X-API-Key": _core_api_key(),
./admin_gateway/routers/admin.py:236:@router.get("/csrf-token", response_model=CSRFTokenResponse)
./admin_gateway/routers/admin.py:237:async def get_csrf_token(
./admin_gateway/routers/admin.py:241:    """Get CSRF token for state-changing requests.
./admin_gateway/routers/admin.py:243:    The token is also set in a cookie. Include the token value
./admin_gateway/routers/admin.py:252:    # Get token from cookie or generate new one
./admin_gateway/routers/admin.py:253:    token = request.cookies.get(config.csrf_cookie_name)
./admin_gateway/routers/admin.py:254:    if not token:
./admin_gateway/routers/admin.py:255:        token = csrf._generate_token()
./admin_gateway/routers/admin.py:259:            "csrf_token": token,
./admin_gateway/routers/admin.py:263:    csrf.set_token_cookie(response, token)
./admin_gateway/routers/auth.py:65:            csrf.set_token_cookie(response)
./admin_gateway/routers/auth.py:90:async def csrf_token(
./admin_gateway/routers/auth.py:94:    """Return a CSRF token tied to the session."""
./admin_gateway/routers/auth.py:96:    token = csrf.set_token_cookie(response)
./admin_gateway/routers/auth.py:97:    response = JSONResponse(content={"csrf_token": token})
./admin_gateway/routers/auth.py:98:    csrf.set_token_cookie(response, token)
./admin_gateway/routers/auth.py:115:    Exchanges authorization code for tokens and creates session.
./admin_gateway/routers/auth.py:126:        # Exchange code for tokens
./admin_gateway/routers/auth.py:127:        tokens = await oidc.exchange_code(code, state)
./admin_gateway/routers/auth.py:129:        # Create session from tokens
./admin_gateway/routers/auth.py:130:        session = await oidc.create_session_from_tokens(tokens)
./admin_gateway/routers/auth.py:141:        csrf.set_token_cookie(response)
./admin_gateway/routers/auth.py:173:    csrf.clear_token_cookie(response)
./admin_gateway/routers/auth.py:195:    csrf.clear_token_cookie(response)
./admin_gateway/tests/conftest.py:29:            "key": "fgk.mock.token",
./admin_gateway/tests/conftest.py:46:            "new_key": "fgk.rotated.token",
./admin_gateway/tests/conftest.py:97:    monkeypatch.setenv("FG_SESSION_SECRET", "test-session-secret")
./admin_gateway/tests/conftest.py:151:    monkeypatch.setenv("FG_SESSION_SECRET", "test-session-secret")
./admin_gateway/tests/conftest.py:183:        response = client.get("/admin/csrf-token")
./admin_gateway/tests/conftest.py:186:        return {data["header_name"]: data["csrf_token"]}
./admin_gateway/tests/test_audit_endpoints.py:38:    csrf = client.get("/admin/csrf-token")
./admin_gateway/tests/test_audit_endpoints.py:39:    token = csrf.json()["csrf_token"]
./admin_gateway/tests/test_audit_endpoints.py:43:        headers={header_name: token},
./admin_gateway/tests/test_auth.py:16:    monkeypatch.setenv("FG_SESSION_SECRET", "test-session-secret")
./admin_gateway/tests/test_auth.py:30:    monkeypatch.setenv("FG_SESSION_SECRET", "test-session-secret")
./admin_gateway/tests/test_auth.py:33:    monkeypatch.setenv("FG_OIDC_CLIENT_SECRET", "secret")
./admin_gateway/tests/test_auth_csrf.py:20:        session_secret="test-secret-key-for-csrf-testing",
./admin_gateway/tests/test_auth_csrf.py:28:    """Tests for CSRF token generation."""
./admin_gateway/tests/test_auth_csrf.py:30:    def test_generate_token_format(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:31:        """Test token has correct format: random.timestamp.signature."""
./admin_gateway/tests/test_auth_csrf.py:32:        token = csrf._generate_token()
./admin_gateway/tests/test_auth_csrf.py:33:        parts = token.split(".")
./admin_gateway/tests/test_auth_csrf.py:39:    def test_generate_unique_tokens(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:40:        """Test each generated token is unique."""
./admin_gateway/tests/test_auth_csrf.py:41:        tokens = [csrf._generate_token() for _ in range(100)]
./admin_gateway/tests/test_auth_csrf.py:42:        assert len(set(tokens)) == 100
./admin_gateway/tests/test_auth_csrf.py:44:    def test_token_timestamp_is_current(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:45:        """Test token timestamp is close to current time."""
./admin_gateway/tests/test_auth_csrf.py:46:        token = csrf._generate_token()
./admin_gateway/tests/test_auth_csrf.py:47:        timestamp = int(token.split(".")[1])
./admin_gateway/tests/test_auth_csrf.py:52:    """Tests for CSRF token validation."""
./admin_gateway/tests/test_auth_csrf.py:54:    def test_validate_valid_token(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:55:        """Test valid token passes validation."""
./admin_gateway/tests/test_auth_csrf.py:56:        token = csrf._generate_token()
./admin_gateway/tests/test_auth_csrf.py:57:        assert csrf._validate_token(token) is True
./admin_gateway/tests/test_auth_csrf.py:61:        assert csrf._validate_token("not-a-valid-token") is False
./admin_gateway/tests/test_auth_csrf.py:63:        assert csrf._validate_token("only.two.parts") is False
./admin_gateway/tests/test_auth_csrf.py:64:        assert csrf._validate_token("single") is False
./admin_gateway/tests/test_auth_csrf.py:65:        assert csrf._validate_token("") is False
./admin_gateway/tests/test_auth_csrf.py:69:        token = csrf._generate_token()
./admin_gateway/tests/test_auth_csrf.py:70:        parts = token.split(".")
./admin_gateway/tests/test_auth_csrf.py:71:        bad_token = f"{parts[0]}.{parts[1]}.wrongsignature!"
./admin_gateway/tests/test_auth_csrf.py:72:        assert csrf._validate_token(bad_token) is False
./admin_gateway/tests/test_auth_csrf.py:74:    def test_validate_expired_token(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:75:        """Test expired token fails validation."""
./admin_gateway/tests/test_auth_csrf.py:76:        # Create token with old timestamp
./admin_gateway/tests/test_auth_csrf.py:83:        sig = hmac.new(csrf._secret, data, hashlib.sha256).hexdigest()[:16]
./admin_gateway/tests/test_auth_csrf.py:84:        old_token = f"{random_part}.{old_timestamp}.{sig}"
./admin_gateway/tests/test_auth_csrf.py:86:        assert csrf._validate_token(old_token) is False
./admin_gateway/tests/test_auth_csrf.py:90:        token = csrf._generate_token()
./admin_gateway/tests/test_auth_csrf.py:91:        parts = token.split(".")
./admin_gateway/tests/test_auth_csrf.py:94:        assert csrf._validate_token(tampered) is False
./admin_gateway/tests/test_auth_csrf.py:123:    def test_set_token_cookie(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:124:        """Test setting CSRF token cookie."""
./admin_gateway/tests/test_auth_csrf.py:128:        token = csrf.set_token_cookie(response)
./admin_gateway/tests/test_auth_csrf.py:130:        assert token is not None
./admin_gateway/tests/test_auth_csrf.py:131:        assert csrf._validate_token(token) is True
./admin_gateway/tests/test_auth_csrf.py:133:    def test_set_custom_token(self, csrf):
./admin_gateway/tests/test_auth_csrf.py:134:        """Test setting custom CSRF token."""
./admin_gateway/tests/test_auth_csrf.py:138:        custom_token = "custom.123456.abcdef0123456789"
./admin_gateway/tests/test_auth_csrf.py:139:        returned = csrf.set_token_cookie(response, token=custom_token)
./admin_gateway/tests/test_auth_csrf.py:141:        assert returned == custom_token
./admin_gateway/tests/test_auth_integration.py:32:            "FG_SESSION_SECRET": "test-session-secret",
./admin_gateway/tests/test_auth_integration.py:53:            "FG_SESSION_SECRET": "test-session-secret",
./admin_gateway/tests/test_auth_integration.py:110:    def test_api_keys_requires_auth(self, client_no_bypass):
./admin_gateway/tests/test_auth_integration.py:154:    def test_api_keys_with_bypass(self, client_with_bypass):
./admin_gateway/tests/test_auth_integration.py:187:        """Test POST without CSRF token is blocked."""
./admin_gateway/tests/test_auth_integration.py:196:        """Test POST with CSRF token is allowed."""
./agent/agent_main.py:133:def post_json(url: str, api_key: str, payload: Dict[str, Any], timeout_s: int = 10) -> tuple[int, str]:
./agent/agent_main.py:141:            "x-api-key": api_key,
./agent/agent_main.py:185:def sender_loop(q: DiskQueue, core_url: str, api_key: str) -> None:
./agent/agent_main.py:190:    if not api_key:
./agent/agent_main.py:210:            status, body = post_json(ingest_url, api_key=api_key, payload=wire)
./agent/app/core_client.py:10:    def __init__(self, base_url: str, api_key: str, tenant_id: str, source: str):
./agent/app/core_client.py:12:        self.api_key = api_key.strip() if api_key else ""
./agent/app/core_client.py:21:        if self.api_key:
./agent/app/core_client.py:22:            headers["X-API-Key"] = self.api_key
./agent/app/main.py:39:    api_key = os.getenv("FG_AGENT_API_KEY", "").strip()
./agent/app/main.py:44:    client = CoreClient(base_url=base_url, api_key=api_key, tenant_id=tenant_id, source=source)
./agent/app/scripts/create_api_key.py:1:# scripts/create_api_key.py
./agent/app/scripts/create_api_key.py:4:import secrets
./agent/app/scripts/create_api_key.py:31:        "\n[create_api_key] ERROR: Could not locate an 'api' package.\n"
./agent/app/scripts/create_api_key.py:46:from api.db_models import ApiKey, hash_api_key  # noqa: E402
./agent/app/scripts/create_api_key.py:55:        print("usage: python scripts/create_api_key.py <PREFIX> <scopes_csv> [name]")
./agent/app/scripts/create_api_key.py:56:        print('example: python scripts/create_api_key.py ADMIN "decisions:read,defend:write,ingest:write" "Admin key"')
./agent/app/scripts/create_api_key.py:65:    raw = prefix + secrets.token_urlsafe(32)
./agent/app/scripts/create_api_key.py:66:    key_hash = hash_api_key(raw)
./api/admin.py:33:    list_api_keys,
./api/admin.py:36:    revoke_api_key,
./api/admin.py:37:    rotate_api_key_by_prefix,
./api/admin.py:212:    "api_key",
./api/admin.py:214:    "client_secret",
./api/admin.py:215:    "client-secret",
./api/admin.py:216:    "access_token",
./api/admin.py:217:    "refresh_token",
./api/admin.py:218:    "id_token",
./api/admin.py:219:    "token",
./api/admin.py:220:    "secret",
./api/admin.py:228:    return any(fragment in normalized for fragment in ("token", "secret", "api-key"))
./api/admin.py:231:def _redact_secrets(value: Any) -> Any:
./api/admin.py:238:                redacted[key] = _redact_secrets(item)
./api/admin.py:241:        return [_redact_secrets(item) for item in value]
./api/admin.py:591:    keys = list_api_keys(tenant_id=bound_tenant, include_disabled=include_disabled)
./api/admin.py:673:            details = _redact_secrets(details)
./api/admin.py:773:                    details = _redact_secrets(details)
./api/admin.py:910:    keys = list_api_keys(tenant_id=bound_tenant, include_disabled=True)
./api/admin.py:914:    revoked = revoke_api_key(key_prefix, tenant_id=bound_tenant)
./api/admin.py:947:        result = rotate_api_key_by_prefix(
./api/admin.py:1054:        from api.key_rotation import rotate_api_key
./api/admin.py:1061:    result = rotate_api_key(key_prefix)
./api/auth.py:6:to auth_scopes.verify_api_key_detailed(), which is the SINGLE SOURCE OF TRUTH.
./api/auth.py:48:async def verify_api_key(
./api/auth.py:50:    x_api_key: Optional[str] = Depends(API_KEY_HEADER),
./api/auth.py:56:    Delegates ALL verification logic to auth_scopes.verify_api_key_detailed()
./api/auth.py:67:    raw = auth_scopes._extract_key(request, x_api_key)
./api/auth.py:70:    result = auth_scopes.verify_api_key_detailed(
./api/auth.py:90:    __: None = Depends(verify_api_key),
./api/auth_scopes.py:10:import secrets
./api/auth_scopes.py:51:def _key_lookup_hash(secret: str, pepper: str) -> str:
./api/auth_scopes.py:53:        pepper.encode("utf-8"), secret.encode("utf-8"), hashlib.sha256
./api/auth_scopes.py:78:def hash_key(secret: str) -> tuple[str, str, dict[str, int], str]:
./api/auth_scopes.py:82:    hashed = hasher.hash(f"{secret}:{pepper}")
./api/auth_scopes.py:83:    lookup = _key_lookup_hash(secret, pepper)
./api/auth_scopes.py:87:def verify_key(secret: str, stored_hash: str, hash_alg: Optional[str]) -> bool:
./api/auth_scopes.py:92:            return hasher.verify(stored_hash, f"{secret}:{pepper}")
./api/auth_scopes.py:98:    return _constant_time_compare(_sha256_hex(secret), stored_hash)
./api/auth_scopes.py:106:def _decode_token_payload(token: str) -> Optional[dict]:
./api/auth_scopes.py:107:    """Decode base64url-encoded token payload, return None on failure."""
./api/auth_scopes.py:109:        padding = 4 - (len(token) % 4)
./api/auth_scopes.py:111:            token += "=" * padding
./api/auth_scopes.py:112:        raw = base64.urlsafe_b64decode(token)
./api/auth_scopes.py:119:    """Check if key is expired based on token payload."""
./api/auth_scopes.py:195:def _extract_key(request: Request, x_api_key: Optional[str]) -> Optional[str]:
./api/auth_scopes.py:205:    if x_api_key and str(x_api_key).strip():
./api/auth_scopes.py:206:        return str(x_api_key).strip()
./api/auth_scopes.py:209:        os.getenv("FG_UI_COOKIE_NAME") or "fg_api_key"
./api/auth_scopes.py:210:    ).strip() or "fg_api_key"
./api/auth_scopes.py:223:    secret: Optional[str] = None,
./api/auth_scopes.py:226:    Mint a key and persist it into sqlite table `api_keys`:
./api/auth_scopes.py:227:      api_keys(prefix, key_hash, scopes_csv, enabled)
./api/auth_scopes.py:230:      <prefix>.<token>.<secret>
./api/auth_scopes.py:244:    if secret is None:
./api/auth_scopes.py:245:        secret = secrets.token_urlsafe(32)
./api/auth_scopes.py:255:    token = _b64url(
./api/auth_scopes.py:258:    key_hash, hash_alg, hash_params, key_lookup = hash_key(secret)
./api/auth_scopes.py:263:        cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:272:            raise RuntimeError("api_keys schema missing hash columns; run migrations")
./api/auth_scopes.py:321:            raise RuntimeError("api_keys table has no usable columns for insert")
./api/auth_scopes.py:326:        con.execute(f"INSERT INTO api_keys({qcols}) VALUES({qmarks})", params)
./api/auth_scopes.py:331:    return f"{prefix}.{token}.{secret}"
./api/auth_scopes.py:369:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:379:                    """UPDATE api_keys
./api/auth_scopes.py:420:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:434:                f"SELECT expires_at FROM api_keys WHERE prefix=? AND {identifier_col}=? LIMIT 1",
./api/auth_scopes.py:498:def verify_api_key_raw(
./api/auth_scopes.py:507:    result = verify_api_key_detailed(
./api/auth_scopes.py:518:def verify_api_key_detailed(
./api/auth_scopes.py:590:                cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:605:                        f"SELECT {select_clause} FROM api_keys WHERE prefix=? AND key_lookup=? LIMIT 1",
./api/auth_scopes.py:613:                        f"SELECT {select_clause} FROM api_keys WHERE prefix=? AND key_hash=? LIMIT 1",
./api/auth_scopes.py:628:    token_payload = None
./api/auth_scopes.py:635:    secret_for_verify: Optional[str] = None
./api/auth_scopes.py:640:        token = parts[1] if len(parts) > 1 else ""
./api/auth_scopes.py:641:        secret_val = parts[-1]
./api/auth_scopes.py:642:        secret_for_verify = secret_val
./api/auth_scopes.py:644:            key_lookup = _key_lookup_hash(secret_val, _get_key_pepper())
./api/auth_scopes.py:647:        key_hash = _sha256_hex(secret_val)
./api/auth_scopes.py:654:                    "canary_token_accessed",
./api/auth_scopes.py:657:                    reason="canary_token",
./api/auth_scopes.py:662:                    valid=False, reason="canary_token", key_prefix=key_prefix
./api/auth_scopes.py:667:        token_payload = _decode_token_payload(token)
./api/auth_scopes.py:669:        if check_expiration and _is_key_expired(token_payload):
./api/auth_scopes.py:674:                reason="key_expired_token",
./api/auth_scopes.py:679:                valid=False, reason="key_expired_token", key_prefix=key_prefix
./api/auth_scopes.py:698:                    "canary_token_accessed",
./api/auth_scopes.py:701:                    reason="canary_token",
./api/auth_scopes.py:706:                    valid=False, reason="canary_token", key_prefix=key_prefix
./api/auth_scopes.py:711:        secret_for_verify = raw
./api/auth_scopes.py:713:            from api.db_models import hash_api_key as _hash_api_key
./api/auth_scopes.py:715:            key_hash = _hash_api_key(raw)
./api/auth_scopes.py:779:    if key_hash and secret_for_verify:
./api/auth_scopes.py:780:        if not verify_key(secret_for_verify, key_hash, hash_alg):
./api/auth_scopes.py:806:                        secret_for_verify
./api/auth_scopes.py:811:                            "UPDATE api_keys SET key_hash=?, hash_alg=?, hash_params=?, key_lookup=? WHERE id=?",
./api/auth_scopes.py:882:def require_api_key_always(
./api/auth_scopes.py:884:    x_api_key: Optional[str] = Header(default=None, alias="X-API-Key"),
./api/auth_scopes.py:887:    got = _extract_key(request, x_api_key)
./api/auth_scopes.py:891:    result = verify_api_key_detailed(
./api/auth_scopes.py:906:def verify_api_key(
./api/auth_scopes.py:908:    x_api_key: Optional[str] = Header(default=None, alias="X-API-Key"),
./api/auth_scopes.py:910:    return require_api_key_always(request, x_api_key, required_scopes=None)
./api/auth_scopes.py:984:        x_api_key: Optional[str] = Header(default=None, alias="X-API-Key"),
./api/auth_scopes.py:986:        return require_api_key_always(
./api/auth_scopes.py:987:            request, x_api_key, required_scopes=needed or None
./api/auth_scopes.py:996:def revoke_api_key(
./api/auth_scopes.py:1008:        cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:1013:            query = "UPDATE api_keys SET enabled=0 WHERE prefix=? AND key_hash=?"
./api/auth_scopes.py:1016:            query = "UPDATE api_keys SET enabled=0 WHERE prefix=?"
./api/auth_scopes.py:1034:def rotate_api_key_by_prefix(
./api/auth_scopes.py:1047:            "SELECT id, scopes_csv, enabled, tenant_id, key_hash FROM api_keys WHERE prefix=? LIMIT 1",
./api/auth_scopes.py:1067:        new_secret = parts[-1]
./api/auth_scopes.py:1069:            new_lookup = _key_lookup_hash(new_secret, _get_key_pepper())
./api/auth_scopes.py:1073:        cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:1078:                "UPDATE api_keys SET rotated_from=? WHERE key_lookup=?",
./api/auth_scopes.py:1084:            con.execute("UPDATE api_keys SET enabled=0 WHERE id=?", (key_id,))
./api/auth_scopes.py:1105:def list_api_keys(
./api/auth_scopes.py:1115:        cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/auth_scopes.py:1132:        query = f"SELECT {','.join(select_cols)} FROM api_keys"
./api/auth_scopes.py:1174:    "verify_api_key_raw",
./api/auth_scopes.py:1175:    "verify_api_key_detailed",
./api/auth_scopes.py:1176:    "verify_api_key",
./api/auth_scopes.py:1177:    "require_api_key_always",
./api/auth_scopes.py:1180:    "revoke_api_key",
./api/auth_scopes.py:1181:    "rotate_api_key_by_prefix",
./api/auth_scopes.py:1182:    "list_api_keys",
./api/config/startup_validation.py:93:        "secret",
./api/config/startup_validation.py:94:        "password",
./api/config/startup_validation.py:113:        self._check_api_key(report)
./api/config/startup_validation.py:130:    def _check_api_key(self, report: StartupValidationReport) -> None:
./api/config/startup_validation.py:132:        api_key = _env_str("FG_API_KEY", "")
./api/config/startup_validation.py:134:        if not api_key:
./api/config/startup_validation.py:137:                name="api_key_missing",
./api/config/startup_validation.py:144:        if api_key.lower() in self.INSECURE_API_KEYS:
./api/config/startup_validation.py:147:                name="api_key_security",
./api/config/startup_validation.py:153:        elif len(api_key) < 16:
./api/config/startup_validation.py:156:                name="api_key_length",
./api/config/startup_validation.py:158:                message=f"FG_API_KEY is too short ({len(api_key)} chars). "
./api/config/startup_validation.py:164:                name="api_key_security",
./api/config/startup_validation.py:307:        api_key = _env_str("FG_API_KEY", "")
./api/config/startup_validation.py:312:            auth_enabled = bool(api_key)
./api/config/startup_validation.py:421:        webhook_secret = _env_str("FG_WEBHOOK_SECRET", "")
./api/config/startup_validation.py:423:        if self.is_production and not webhook_secret:
./api/config/startup_validation.py:425:                name="webhook_secret_missing",
./api/config/startup_validation.py:430:        elif webhook_secret and len(webhook_secret) < 32:
./api/config/startup_validation.py:432:                name="webhook_secret_weak",
./api/config/startup_validation.py:434:                message=f"FG_WEBHOOK_SECRET is weak ({len(webhook_secret)} chars). "
./api/config/startup_validation.py:438:        elif webhook_secret:
./api/config/startup_validation.py:442:                message="Webhook secret configured.",
./api/config/startup_validation.py:507:        jwt_secret = _env_str("FG_JWT_SECRET", "")
./api/config/startup_validation.py:525:            if not jwt_secret:
./api/config/startup_validation.py:527:                    name="jwt_secret_missing",
./api/config/startup_validation.py:529:                    message="FG_JWT_SECRET not set. Consider setting for JWT token signing.",
./api/config/startup_validation.py:532:            elif len(jwt_secret) < 32:
./api/config/startup_validation.py:534:                    name="jwt_secret_weak",
./api/config.py:29:    api_key: str | None = None
./api/config.py:41:        settings.auth_enabled = bool(settings.api_key)
./api/db/api_keys_store.py:12:def insert_api_key(
./api/db/api_keys_store.py:21:    Insert an API key row into api_keys using current schema:
./api/db/api_keys_store.py:48:        INSERT INTO api_keys (name, prefix, key_hash, key_lookup, hash_alg, hash_params, scopes_csv, enabled)
./api/db.py:271:    api_keys_columns = {
./api/db.py:289:        if "api_keys" in tables:
./api/db.py:290:            _sqlite_add_columns(conn, "api_keys", api_keys_columns)
./api/db_migrations.py:118:        "api_keys",
./api/db_models.py:26:def hash_api_key(api_key: str) -> str:
./api/db_models.py:28:    return hashlib.sha256(api_key.encode("utf-8")).hexdigest()
./api/db_models.py:43:    __tablename__ = "api_keys"
./api/governance.py:14:from api.auth_scopes import require_scopes, verify_api_key
./api/governance.py:109:        Depends(verify_api_key),
./api/key_rotation.py:134:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/key_rotation.py:145:                f"SELECT {','.join(select)} FROM api_keys WHERE prefix = ?",
./api/key_rotation.py:216:                    "SELECT prefix FROM api_keys WHERE rotated_from = ?",
./api/key_rotation.py:248:                "SELECT prefix FROM api_keys WHERE enabled = 1"
./api/key_rotation.py:304:                "SELECT scopes_csv, tenant_id FROM api_keys WHERE prefix = ?",
./api/key_rotation.py:355:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/key_rotation.py:360:                    "UPDATE api_keys SET rotated_from = ? WHERE prefix = ?",
./api/key_rotation.py:403:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/key_rotation.py:418:                FROM api_keys old
./api/key_rotation.py:419:                INNER JOIN api_keys new ON new.rotated_from = old.prefix
./api/key_rotation.py:428:                    "UPDATE api_keys SET enabled = 0 WHERE prefix = ?",
./api/key_rotation.py:460:def rotate_api_key(
./api/key_rotation.py:478:    "rotate_api_key",
./api/keys.py:24:    revoke_api_key,
./api/keys.py:25:    list_api_keys,
./api/keys.py:109:    """Information about an API key (without the secret)."""
./api/keys.py:217:    Does not return the actual key secrets.
./api/keys.py:226:        keys = list_api_keys(
./api/keys.py:256:        revoked = revoke_api_key(req.prefix, tenant_id=bound_tenant)
./api/keys.py:376:    secret_val = parts[-1]
./api/keys.py:378:        old_key_lookup = _key_lookup_hash(secret_val, _get_key_pepper())
./api/keys.py:390:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/keys.py:394:                    "SELECT id, scopes_csv, enabled, tenant_id, key_hash FROM api_keys WHERE prefix=? AND key_lookup=? LIMIT 1",
./api/keys.py:398:                old_key_hash = _sha256_hex(secret_val)
./api/keys.py:400:                    "SELECT id, scopes_csv, enabled, tenant_id, key_hash FROM api_keys WHERE prefix=? AND key_hash=? LIMIT 1",
./api/keys.py:429:            new_secret = new_parts[-1]
./api/keys.py:431:                new_key_lookup = _key_lookup_hash(new_secret, _get_key_pepper())
./api/keys.py:436:                    "UPDATE api_keys SET rotated_from=? WHERE key_lookup=?",
./api/keys.py:444:                    "UPDATE api_keys SET enabled=0 WHERE id=?",
./api/main.py:126:UI_COOKIE_NAME = os.getenv("FG_UI_COOKIE_NAME", "fg_api_key")
./api/main.py:157:def _global_expected_api_key() -> str:
./api/main.py:330:        api_key = _hdr(req, "X-API-Key")
./api/main.py:331:        if not api_key:
./api/main.py:333:            api_key = str(ck).strip() if ck and str(ck).strip() else None
./api/main.py:335:        if not api_key:
./api/main.py:355:        expected = getattr(tenant, "api_key", None)
./api/main.py:356:        if expected is None or str(expected) != str(api_key):
./api/main.py:367:        api_key = _hdr(req, "X-API-Key")
./api/main.py:368:        if not api_key:
./api/main.py:370:            api_key = str(ck).strip() if ck and str(ck).strip() else None
./api/main.py:372:        if not api_key:
./api/main.py:375:        if str(api_key) != str(_global_expected_api_key()):
./api/main.py:396:                "/ui/token",
./api/middleware/auth_gate.py:14:    public_paths: tuple[str, ...] = ("/health", "/health/ready", "/ui", "/ui/token")
./api/middleware/auth_gate.py:36:      - validate key via auth_scopes.verify_api_key_raw
./api/ratelimit.py:30:    tokens: float
./api/ratelimit.py:36:    Thread-safe in-memory token bucket rate limiter.
./api/ratelimit.py:79:                bucket = MemoryBucket(tokens=capacity, last_ts=now)
./api/ratelimit.py:82:            # Refill tokens
./api/ratelimit.py:84:            bucket.tokens = min(capacity, bucket.tokens + (delta * rate_per_sec))
./api/ratelimit.py:88:            if bucket.tokens >= cost:
./api/ratelimit.py:89:                bucket.tokens -= cost
./api/ratelimit.py:90:                remaining = int(bucket.tokens)
./api/ratelimit.py:94:            needed = cost - bucket.tokens
./api/ratelimit.py:188:    rate_per_sec: float  # refill rate (tokens/sec)
./api/ratelimit.py:250:def _api_key_from_request(request: Request) -> str:
./api/ratelimit.py:301:# Redis token bucket (atomic)
./api/ratelimit.py:317:local data = redis.call("HMGET", key, "tokens", "ts")
./api/ratelimit.py:318:local tokens = tonumber(data[1])
./api/ratelimit.py:321:if tokens == nil then
./api/ratelimit.py:322:  tokens = capacity
./api/ratelimit.py:332:tokens = math.min(capacity, tokens + (delta * rate))
./api/ratelimit.py:336:local remaining = tokens
./api/ratelimit.py:338:if tokens >= cost then
./api/ratelimit.py:340:  tokens = tokens - cost
./api/ratelimit.py:341:  remaining = tokens
./api/ratelimit.py:347:-- compute reset: time until token available
./api/ratelimit.py:350:  local needed = cost - tokens
./api/ratelimit.py:356:redis.call("HMSET", key, "tokens", tokens, "ts", ts)
./api/ratelimit.py:433:    api_key = _api_key_from_request(request)
./api/ratelimit.py:434:    if api_key and api_key in cfg.bypass_keys:
./api/stats.py:263:        "auth.password_spray",
./api/token_useage.py:13:logger = logging.getLogger("frostgate.token_usage")
./api/token_useage.py:16:    "frostgate_token_usage_requests_total",
./api/token_useage.py:17:    "Total API calls grouped by token fingerprint, endpoint, and status family",
./api/token_useage.py:18:    ["token_fingerprint", "endpoint", "status_family"],
./api/token_useage.py:22:    "frostgate_token_usage_latency_seconds",
./api/token_useage.py:23:    "Request latency for API keys (token fingerprints) per endpoint",
./api/token_useage.py:24:    ["token_fingerprint", "endpoint"],
./api/token_useage.py:79:    """In-process tracker that fingerprints tokens and aggregates usage."""
./api/token_useage.py:86:    def fingerprint(token: str) -> str:
./api/token_useage.py:87:        # Stable, non-reversible identifier so logs/metrics never leak the token itself.
./api/token_useage.py:88:        return hashlib.sha256(token.encode("utf-8")).hexdigest()[:12]
./api/token_useage.py:93:        token: Optional[str],
./api/token_useage.py:99:        token_fp = self.fingerprint(token) if token else "missing"
./api/token_useage.py:103:            stats = self._stats.setdefault(token_fp, TokenUsageStats())
./api/token_useage.py:111:        TOKEN_USAGE_REQUESTS.labels(token_fp, path, status_family).inc()
./api/token_useage.py:112:        TOKEN_USAGE_LATENCY_SECONDS.labels(token_fp, path).observe(latency_ms / 1000.0)
./api/token_useage.py:115:            "token_usage",
./api/token_useage.py:117:                "token_fingerprint": token_fp,
./api/token_useage.py:125:        return token_fp
./api/token_useage.py:132:token_usage_tracker = TokenUsageTracker()
./api/token_useage.py:135:async def token_usage_middleware(request: Request, call_next):
./api/token_useage.py:137:    Observes every request to capture where API tokens are being used.
./api/token_useage.py:139:    - Fingerprints the presented token (never logs raw keys)
./api/token_useage.py:140:    - Emits Prometheus metrics per token/endpoint
./api/token_useage.py:149:    api_key = request.headers.get("x-api-key")
./api/token_useage.py:153:    token_fp = token_usage_tracker.record(
./api/token_useage.py:154:        token=api_key,
./api/token_useage.py:161:    request.state.token_fingerprint = token_fp
./api/token_useage.py:165:def get_token_usage_snapshot() -> Dict[str, Dict[str, object]]:
./api/token_useage.py:166:    """Returns an aggregated view of token usage for quick efficiency analysis."""
./api/token_useage.py:168:    return token_usage_tracker.snapshot()
./api/tripwires.py:5:- Canary token detection (honeypot API keys)
./api/tripwires.py:420:    Check if a key prefix matches a canary token.
./api/tripwires.py:543:                "SELECT prefix FROM api_keys WHERE prefix LIKE ? LIMIT 1",
./api/tripwires.py:552:            import secrets
./api/tripwires.py:556:            canary_prefix = f"{CANARY_KEY_PREFIX}{secrets.token_hex(4)}"
./api/tripwires.py:557:            canary_secret = secrets.token_urlsafe(32)
./api/tripwires.py:558:            canary_hash, hash_alg, hash_params, key_lookup = hash_key(canary_secret)
./api/tripwires.py:564:            cols = con.execute("PRAGMA table_info(api_keys)").fetchall()
./api/tripwires.py:569:                    "INSERT INTO api_keys (name, prefix, key_hash, key_lookup, hash_alg, hash_params, scopes_csv, enabled) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
./api/tripwires.py:583:                    "INSERT INTO api_keys (name, prefix, key_hash, scopes_csv, enabled) VALUES (?, ?, ?, ?, ?)",
./api/tripwires.py:594:                    "INSERT INTO api_keys (prefix, key_hash, scopes_csv, enabled) VALUES (?, ?, ?, ?)",
./api/ui.py:15:    # IMPORTANT: do NOT put rate_limit_guard here or it will block /ui/token GET
./api/ui.py:18:UI_COOKIE_NAME = os.getenv("FG_UI_COOKIE_NAME", "fg_api_key")
./api/ui.py:83:    via require_api_key_always/require_scopes. UI is just a UX convenience gate.
./api/ui.py:339:        <div class="muted">Dev: call <code>/ui/token</code> once with <code>X-API-Key</code> to mint cookie.</div>
./api/ui.py:836:  csrfToken = data.csrf_token;
./api/ui.py:852:  const token = await ensureCsrf();
./api/ui.py:853:  if (!token) {
./api/ui.py:854:    exportStatus.textContent = "CSRF token unavailable.";
./api/ui.py:862:      "X-CSRF-Token": token,
./api/ui.py:982:@router.get("/token")
./api/ui.py:983:def ui_token(request: Request, response: Response):
./api/ui.py:984:    api_key = _get_header_key(request)
./api/ui.py:985:    if not api_key:
./api/ui.py:989:        api_key,
./api/ui_dashboards.py:7:import secrets
./api/ui_dashboards.py:19:from api.auth_scopes import bind_tenant_id, require_api_key_always, require_scopes
./api/ui_dashboards.py:226:    token = request.headers.get(CSRF_HEADER_NAME)
./api/ui_dashboards.py:228:    if not token or not cookie or token != cookie:
./api/ui_dashboards.py:229:        raise HTTPException(status_code=403, detail="CSRF token missing or invalid")
./api/ui_dashboards.py:496:@router.get("/scopes", dependencies=[Depends(require_api_key_always)])
./api/ui_dashboards.py:506:@router.get("/csrf", dependencies=[Depends(require_api_key_always)])
./api/ui_dashboards.py:508:    token = secrets.token_urlsafe(32)
./api/ui_dashboards.py:510:        "csrf_token": token,
./api/ui_dashboards.py:519:        token,
./api/ui_dashboards.py:826:    token = secrets.token_urlsafe(24)
./api/ui_dashboards.py:827:    token_path = packet_dir / "token.txt"
./api/ui_dashboards.py:828:    token_path.write_text(token, encoding="utf-8")
./api/ui_dashboards.py:843:        download_url=f"/ui/audit/packet/{packet_id}/download?token={token}",
./api/ui_dashboards.py:857:    token: str = Query(..., min_length=8),
./api/ui_dashboards.py:863:    token_path = packet_dir / "token.txt"
./api/ui_dashboards.py:864:    if not token_path.exists() or token_path.read_text(encoding="utf-8") != token:
./api/ui_dashboards.py:865:        raise HTTPException(status_code=403, detail="Invalid token")
./api/webhook_security.py:71:    secret: str,
./api/webhook_security.py:79:        HMAC(secret, timestamp.payload)
./api/webhook_security.py:91:            secret.encode("utf-8"),
./api/webhook_security.py:97:            secret.encode("utf-8"),
./api/webhook_security.py:111:    secret: Optional[str] = None,
./api/webhook_security.py:122:        secret: The webhook secret (defaults to FG_WEBHOOK_SECRET env)
./api/webhook_security.py:129:    secret = secret or WEBHOOK_SECRET
./api/webhook_security.py:132:    # Check if secret is configured
./api/webhook_security.py:133:    if not secret:
./api/webhook_security.py:134:        log.warning("Webhook signature verification skipped: no secret configured")
./api/webhook_security.py:137:            error="Signature verification disabled (no secret configured)",
./api/webhook_security.py:182:    expected = compute_signature(payload, secret, timestamp, algorithm)
./api/webhook_security.py:203:    secret: Optional[str] = None,
./api/webhook_security.py:211:    secret = secret or WEBHOOK_SECRET
./api/webhook_security.py:214:    if not secret:
./api/webhook_security.py:215:        raise ValueError("Webhook secret not configured")
./api/webhook_security.py:217:    signature = compute_signature(payload, secret, timestamp, algorithm)
./api/webhook_security.py:238:        secret: Optional[str] = None,
./api/webhook_security.py:244:        self.secret = secret or WEBHOOK_SECRET
./api/webhook_security.py:293:            secret=self.secret,
./backend/tests/_harness.py:11:def _require_api_key() -> str:
./backend/tests/_harness.py:12:    api_key = os.environ.get("FG_API_KEY", "").strip()
./backend/tests/_harness.py:13:    if not api_key:
./backend/tests/_harness.py:15:    return api_key
./backend/tests/_harness.py:18:API_KEY_DEFAULT = _require_api_key()
./backend/tests/_harness.py:45:    api_key: str = API_KEY_DEFAULT,
./backend/tests/_harness.py:79:            "FG_API_KEY": api_key,
./backend/tests/conftest.py:31:def _require_api_key() -> str:
./backend/tests/conftest.py:32:    api_key = os.environ.get("FG_API_KEY", "").strip()
./backend/tests/conftest.py:33:    if not api_key:
./backend/tests/conftest.py:35:    return api_key
./backend/tests/conftest.py:44:        monkeypatch.setenv("FG_API_KEY", _require_api_key())
./engine/roe.py:29:        "ao_required_for_secret_high": True,
./engine/setting.py:19:    api_key: str | None = None
./engine/tied.py:25:    "secret": 1.2,
./jobs/sim_validator/job.py:151:        name="guardian_secret_classification",
./scripts/cis_check.py:112:def check_no_secrets_in_env() -> CheckResult:
./scripts/cis_check.py:116:    Check for potential secrets in docker-compose.yml and .env files.
./scripts/cis_check.py:119:        (r"password\s*[:=]\s*['\"][^'\"]+['\"]", "hardcoded password"),
./scripts/cis_check.py:120:        (r"secret\s*[:=]\s*['\"][^'\"]+['\"]", "hardcoded secret"),
./scripts/cis_check.py:143:            description="Configuration files must not contain hardcoded secrets",
./scripts/cis_check.py:146:            message=f"Potential secrets found: {', '.join(issues)}",
./scripts/cis_check.py:147:            remediation="Use environment variables or secret files for sensitive values",
./scripts/cis_check.py:153:        description="Configuration files must not contain hardcoded secrets",
./scripts/cis_check.py:156:        message="No hardcoded secrets detected",
./scripts/cis_check.py:160:def check_secret_files_permissions() -> CheckResult:
./scripts/cis_check.py:164:    Files containing secrets should be readable only by owner.
./scripts/cis_check.py:166:    secret_paths = [
./scripts/cis_check.py:167:        Path("secrets/fg_api_keys.txt"),
./scripts/cis_check.py:172:    for path in secret_paths:
./scripts/cis_check.py:189:            remediation="Run: chmod 600 <secret-file>",
./scripts/cis_check.py:322:    Check that Redis password is required in configuration.
./scripts/cis_check.py:473:        check_no_secrets_in_env(),
./scripts/cis_check.py:474:        check_secret_files_permissions(),
./scripts/conftest.py:26:def api_key() -> str:
./scripts/create_api_key.py:3:import secrets
./scripts/create_api_key.py:7:DEFAULT_KEYS_FILE = Path("secrets/fg_api_keys.txt")
./scripts/create_api_key.py:13:            "usage: python scripts/create_api_key.py <PREFIX> <scopes_csv> [name] [keys_file]"
./scripts/create_api_key.py:16:            'example: python scripts/create_api_key.py ADMIN "decisions:read,defend:write,ingest:write" "Admin Key"'
./scripts/create_api_key.py:26:    raw_key = prefix + secrets.token_urlsafe(32)
./scripts/mint_api_key.py:2:import secrets
./scripts/mint_api_key.py:7:from api.db.api_keys_store import insert_api_key
./scripts/mint_api_key.py:24:    raw = f"{prefix}_" + secrets.token_urlsafe(32)
./scripts/mint_api_key.py:32:    insert_api_key(
./scripts/prod_profile_check.py:9:- No default/weak secrets in production config
./scripts/scap_scan.py:118:        "pattern": r"(?:password|passwd|pwd)\s*=\s*['\"][^'\"]{4,}['\"]",
./scripts/scap_scan.py:119:        "description": "Hardcoded password detected",
./scripts/scap_scan.py:120:        "remediation": "Use environment variables or secret management",
./scripts/scap_scan.py:127:        "pattern": r"(?:api[_-]?key|apikey|secret[_-]?key)\s*=\s*['\"][a-zA-Z0-9]{20,}['\"]",
./scripts/scap_scan.py:129:        "remediation": "Use environment variables or secret management",
./scripts/scap_scan.py:196:        "remediation": "Use secrets module for security-sensitive random values",
./scripts/scap_scan.py:224:        "pattern": r"(?:log|print|console\.log)\s*\([^)]*(?:password|secret|token|key)[^)]*\)",
./scripts/seed_apikeys_db.py:8:from api.db_models import ApiKey, hash_api_key
./scripts/seed_apikeys_db.py:44:        key_h = hash_api_key(raw)
./scripts/test_db_write.py:10:def test_defend_persists_decision(base_url, api_key, sqlite_path, clear_decisions):
./scripts/test_db_write.py:21:        headers={"X-API-Key": api_key, "Content-Type": "application/json"},
./scripts/test_demo_invariants.py:9:def _run_seed(mode: str, base_url: str, api_key: str, sqlite_path: str):
./scripts/test_demo_invariants.py:14:        "FG_API_KEY": api_key,
./scripts/test_demo_invariants.py:15:        "API_KEY": api_key,
./scripts/test_demo_invariants.py:24:def test_demo_invariants_spike(base_url, api_key, sqlite_path, clear_decisions):
./scripts/test_demo_invariants.py:25:    _run_seed("spike", base_url, api_key, sqlite_path)
./scripts/test_demo_invariants.py:28:        f"{base_url}/stats/summary", headers={"X-API-Key": api_key}, timeout=10
./scripts/test_demo_invariants.py:41:def test_demo_invariants_drop(base_url, api_key, sqlite_path, clear_decisions):
./scripts/test_demo_invariants.py:42:    _run_seed("drop", base_url, api_key, sqlite_path)
./scripts/test_demo_invariants.py:45:        f"{base_url}/stats/summary", headers={"X-API-Key": api_key}, timeout=10
./scripts/test_ingest_persists.py:18:def _create_api_key(db):
./scripts/test_ingest_persists.py:22:    from api.db_models import ApiKey, hash_api_key
./scripts/test_ingest_persists.py:29:        kwargs["key_hash"] = hash_api_key(raw)
./scripts/test_ingest_persists.py:45:    hashed = hash_api_key(raw)
./scripts/test_stats_contract.py:20:def _run_seed(mode: str, base_url: str, api_key: str, sqlite_path: str):
./scripts/test_stats_contract.py:25:        "FG_API_KEY": api_key,
./scripts/test_stats_contract.py:26:        "API_KEY": api_key,
./scripts/test_stats_contract.py:37:def test_stats_summary_contract_steady(base_url, api_key, sqlite_path, clear_decisions):
./scripts/test_stats_contract.py:38:    _run_seed("steady", base_url, api_key, sqlite_path)
./scripts/test_stats_contract.py:41:        f"{base_url}/stats/summary", headers={"X-API-Key": api_key}, timeout=10
./tests/_harness.py:10:def _require_api_key() -> str:
./tests/_harness.py:11:    api_key = os.environ.get("FG_API_KEY", "").strip()
./tests/_harness.py:12:    if not api_key:
./tests/_harness.py:14:    return api_key
./tests/_harness.py:17:DEFAULT_API_KEY = _require_api_key()
./tests/_harness.py:26:    tmp_path: Path, *, api_key: str, auth_enabled: bool, dev_events_enabled: bool
./tests/_harness.py:32:    os.environ["FG_API_KEY"] = api_key
./tests/_harness.py:70:        app = build_app(auth_enabled=True, api_key=os.environ["FG_API_KEY"], dev_events_enabled=True)
./tests/_harness.py:76:        api_key: str = DEFAULT_API_KEY,
./tests/_harness.py:81:            api_key=api_key,
./tests/conftest.py:35:def _require_api_key() -> str:
./tests/conftest.py:36:    api_key = os.environ.get("FG_API_KEY", "").strip()
./tests/conftest.py:37:    if not api_key:
./tests/conftest.py:39:    return api_key
./tests/conftest.py:51:    _setenv("FG_API_KEY", _require_api_key())
./tests/conftest.py:72:        api_key: str | None = None,
./tests/conftest.py:73:        ui_token_get_enabled: bool = True,
./tests/conftest.py:75:        api_key_value = api_key or _require_api_key()
./tests/conftest.py:81:        monkeypatch.setenv("FG_API_KEY", api_key_value)
./tests/conftest.py:85:            "FG_UI_TOKEN_GET_ENABLED", "1" if ui_token_get_enabled else "0"
./tests/postgres/test_tenant_isolation_postgres.py:42:       WHERE relname IN ('decisions','decision_evidence_artifacts','api_keys','security_audit_log');
./tests/postgres/test_tenant_isolation_postgres.py:46:       WHERE tablename IN ('decisions','decision_evidence_artifacts','api_keys','security_audit_log');
./tests/postgres/test_tenant_isolation_postgres.py:64:                'api_keys',
./tests/postgres/test_tenant_isolation_postgres.py:78:                'api_keys',
./tests/postgres/test_tenant_isolation_postgres.py:109:        "api_keys",
./tests/security/test_key_hashing_kdf.py:9:from api.auth_scopes import mint_key, verify_api_key_detailed
./tests/security/test_key_hashing_kdf.py:29:            "SELECT key_hash, hash_alg, hash_params, key_lookup FROM api_keys LIMIT 1"
./tests/security/test_key_hashing_kdf.py:48:    secret = "legacy-secret"
./tests/security/test_key_hashing_kdf.py:49:    token = _b64url(
./tests/security/test_key_hashing_kdf.py:57:    raw_key = f"fgk.{token}.{secret}"
./tests/security/test_key_hashing_kdf.py:58:    legacy_hash = hashlib.sha256(secret.encode("utf-8")).hexdigest()
./tests/security/test_key_hashing_kdf.py:64:            INSERT INTO api_keys (name, prefix, key_hash, scopes_csv, enabled, tenant_id)
./tests/security/test_key_hashing_kdf.py:73:    result = verify_api_key_detailed(raw=raw_key, required_scopes=None)
./tests/security/test_key_hashing_kdf.py:79:            "SELECT key_hash, hash_alg, key_lookup FROM api_keys WHERE prefix=? LIMIT 1",
./tests/test_admin_audit_tenant_binding.py:245:def test_missing_api_key_returns_401(audit_tenant_client):
./tests/test_admin_audit_tenant_binding.py:257:def test_invalid_api_key_returns_401(audit_tenant_client):
./tests/test_audit_search.py:24:    api_key = mint_key("audit:read", ttl_seconds=3600)
./tests/test_audit_search.py:25:    return client, api_key
./tests/test_audit_search.py:30:    client, api_key = audit_client
./tests/test_audit_search.py:32:    response = client.get("/admin/audit/search", headers={"X-API-Key": api_key})
./tests/test_audit_search.py:39:    client, api_key = audit_client
./tests/test_audit_search.py:68:        headers={"X-API-Key": api_key},
./tests/test_audit_search.py:77:    client, api_key = audit_client
./tests/test_audit_search.py:94:                    "authorization": "Bearer secret",
./tests/test_audit_search.py:95:                    "nested": {"token": "secret-token"},
./tests/test_audit_search.py:104:        headers={"X-API-Key": api_key},
./tests/test_audit_search.py:113:    assert details["nested"]["token"] == "[REDACTED]"
./tests/test_audit_search.py:120:    client, api_key = audit_client
./tests/test_audit_search.py:160:        headers={"X-API-Key": api_key},
./tests/test_audit_search.py:170:        headers={"X-API-Key": api_key},
./tests/test_audit_search.py:195:    client, api_key = audit_client
./tests/test_audit_search.py:216:        headers={"X-API-Key": api_key},
./tests/test_audit_search.py:225:    client, api_key = audit_client
./tests/test_audit_search.py:247:        headers={"X-API-Key": api_key},
./tests/test_auth.py:19:    api_key = os.environ.get("FG_API_KEY", "")
./tests/test_auth.py:24:        if not api_key:
./tests/test_auth.py:26:        os.environ["FG_API_KEY"] = api_key
./tests/test_auth_gate_cookie_fallback.py:11:    api_key = os.environ["FG_API_KEY"]
./tests/test_auth_gate_cookie_fallback.py:12:    monkeypatch.setenv("FG_API_KEY", api_key)
./tests/test_auth_gate_cookie_fallback.py:14:    cookie_name = os.getenv("FG_UI_COOKIE_NAME", "fg_api_key")
./tests/test_auth_gate_cookie_fallback.py:20:        client.cookies.set(cookie_name, api_key)
./tests/test_auth_gate_regression.py:11:def test_ui_token_sets_cookie_with_header(build_app):
./tests/test_auth_gate_regression.py:14:    r = c.get("/ui/token", headers={"x-api-key": API_KEY})
./tests/test_auth_gate_regression.py:32:    r = c.get("/ui/token", headers={"x-api-key": API_KEY})
./tests/test_auth_gate_regression.py:40:def test_ui_token_rejects_query_param_key(build_app):
./tests/test_auth_gate_regression.py:43:    r = c.get("/ui/token", params={"api_key": API_KEY})
./tests/test_auth_hardening.py:58:            oidc_client_secret="test",
./tests/test_auth_hardening.py:83:            oidc_client_secret="test",
./tests/test_auth_hardening.py:103:            oidc_client_secret="",
./tests/test_auth_hardening.py:120:        # All governance endpoints have Depends(verify_api_key)
./tests/test_auth_hardening.py:149:                "FG_API_KEY": "secret",  # Insecure default
./tests/test_auth_hardening.py:170:                "FG_API_KEY": "secret",
./tests/test_auth_tenants.py:11:    def __init__(self, tenant_id: str, api_key: str, status: str = "active"):
./tests/test_auth_tenants.py:13:        self.api_key = api_key
./tests/test_auth_tenants.py:27:                tenant_id="acme-prod", api_key="tenant-secret", status="active"
./tests/test_auth_tenants.py:39:                "x-api-key": "tenant-secret",
./tests/test_auth_tenants.py:55:            tenant_id=tenant_id, api_key="tenant-secret", status="revoked"
./tests/test_auth_tenants.py:66:                "x-api-key": "tenant-secret",
./tests/test_auth_tenants.py:83:            tenant_id=tenant_id, api_key="tenant-secret", status="active"
./tests/test_compliance_gates.py:257:    def test_scan_detects_hardcoded_password(self):
./tests/test_compliance_gates.py:258:        """Scan detects hardcoded passwords."""
./tests/test_compliance_gates.py:262:            f.write('password = "supersecret123"\n')
./tests/test_compliance_gates.py:292:            f.write('# password = "supersecret123"\n')
./tests/test_contract_feed.py:22:    api_key = os.getenv("FG_API_KEY")
./tests/test_contract_feed.py:23:    if not api_key:
./tests/test_contract_feed.py:25:    return {"X-API-Key": api_key}
./tests/test_core_invariants.py:41:        from api.auth_scopes import verify_api_key_detailed
./tests/test_core_invariants.py:43:        result = verify_api_key_detailed(raw=None, required_scopes=None, request=None)
./tests/test_core_invariants.py:50:        from api.auth_scopes import verify_api_key_detailed
./tests/test_core_invariants.py:52:        result = verify_api_key_detailed(
./tests/test_core_invariants.py:62:        from api.auth_scopes import verify_api_key_detailed
./tests/test_core_invariants.py:65:            result = verify_api_key_detailed(
./tests/test_core_invariants.py:73:        from api.auth_scopes import _is_production_env, verify_api_key_detailed
./tests/test_core_invariants.py:79:            result = verify_api_key_detailed(
./tests/test_core_invariants.py:98:            "/ui/token",
./tests/test_core_invariants.py:319:        has_verify_api_key = False
./tests/test_core_invariants.py:324:                if "verify_api_key" in func_name:
./tests/test_core_invariants.py:325:                    has_verify_api_key = True
./tests/test_core_invariants.py:327:        assert has_verify_api_key, (
./tests/test_core_invariants.py:328:            "Governance router must have verify_api_key dependency"
./tests/test_decision_pipeline_unified.py:146:    def test_guardian_secret_caps_disruption(self):
./tests/test_decision_pipeline_unified.py:164:    def test_guardian_secret_sets_gating(self):
./tests/test_explanation_brief.py:14:    api_key = os.getenv("FG_API_KEY")
./tests/test_explanation_brief.py:15:    assert api_key, "FG_API_KEY must be set for this test (env var missing)."
./tests/test_explanation_brief.py:30:        r = client.post("/defend", json=payload, headers={"x-api-key": api_key})
./tests/test_key_lifecycle.py:5:- Expired keys fail (both token and DB expiration)
./tests/test_key_lifecycle.py:8:- Canary token detection triggers audit event
./tests/test_key_lifecycle.py:18:    rotate_api_key_by_prefix,
./tests/test_key_lifecycle.py:19:    verify_api_key_detailed,
./tests/test_key_lifecycle.py:20:    verify_api_key_raw,
./tests/test_key_lifecycle.py:40:    def test_expired_key_from_token_payload_fails(self, fresh_db, monkeypatch):
./tests/test_key_lifecycle.py:41:        """Keys with expired token payload should fail."""
./tests/test_key_lifecycle.py:46:        result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:58:        secret = parts[-1]
./tests/test_key_lifecycle.py:61:        key_lookup = _key_lookup_hash(secret, _get_key_pepper())
./tests/test_key_lifecycle.py:68:                "UPDATE api_keys SET expires_at = ? WHERE prefix = ? AND key_lookup = ?",
./tests/test_key_lifecycle.py:75:        result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:82:        result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:96:        secret = parts[-1]
./tests/test_key_lifecycle.py:99:        key_lookup = _key_lookup_hash(secret, _get_key_pepper())
./tests/test_key_lifecycle.py:104:                "SELECT use_count FROM api_keys WHERE prefix = ? AND key_lookup = ?",
./tests/test_key_lifecycle.py:113:            result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:120:                "SELECT use_count FROM api_keys WHERE prefix = ? AND key_lookup = ?",
./tests/test_key_lifecycle.py:135:        secret = parts[-1]
./tests/test_key_lifecycle.py:138:        key_lookup = _key_lookup_hash(secret, _get_key_pepper())
./tests/test_key_lifecycle.py:143:        result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:150:                "SELECT last_used_at FROM api_keys WHERE prefix = ? AND key_lookup = ?",
./tests/test_key_lifecycle.py:160:    def test_verify_api_key_raw_tracks_usage(self, fresh_db):
./tests/test_key_lifecycle.py:161:        """verify_api_key_raw should update usage stats on success."""
./tests/test_key_lifecycle.py:166:        secret = parts[-1]
./tests/test_key_lifecycle.py:169:        key_lookup = _key_lookup_hash(secret, _get_key_pepper())
./tests/test_key_lifecycle.py:171:        verify_api_key_raw(raw=key)
./tests/test_key_lifecycle.py:176:                "SELECT use_count, last_used_at FROM api_keys WHERE prefix = ? AND key_lookup = ?",
./tests/test_key_lifecycle.py:195:        pre_rotate = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:198:        result = rotate_api_key_by_prefix(prefix, ttl_seconds=3600)
./tests/test_key_lifecycle.py:201:        new_result = verify_api_key_detailed(raw=new_key)
./tests/test_key_lifecycle.py:204:        old_result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:209:    """Test that canary tokens are detected."""
./tests/test_key_lifecycle.py:224:                "INSERT INTO api_keys (name, prefix, key_hash, scopes_csv, enabled, version, use_count) VALUES (?, ?, ?, ?, ?, ?, ?)",
./tests/test_key_lifecycle.py:232:        fake_key = f"{canary_prefix}.token.secret"
./tests/test_key_lifecycle.py:233:        result = verify_api_key_detailed(raw=fake_key)
./tests/test_key_lifecycle.py:236:        assert result.reason == "canary_token"
./tests/test_key_lifecycle.py:241:        result = verify_api_key_detailed(raw=key)
./tests/test_key_lifecycle.py:244:        assert result.reason != "canary_token"
./tests/test_key_lifecycle.py:252:        result = verify_api_key_detailed(raw="")
./tests/test_key_lifecycle.py:259:        result = verify_api_key_detailed(raw="invalid_key_that_does_not_exist")
./tests/test_key_lifecycle.py:267:        result = verify_api_key_detailed(raw=key)
./tests/test_saas_features.py:101:        secret = "test-secret-key"
./tests/test_saas_features.py:104:        signature = compute_signature(payload, secret, timestamp)
./tests/test_saas_features.py:114:        secret = "test-secret-key"
./tests/test_saas_features.py:117:        signature = compute_signature(payload, secret, timestamp)
./tests/test_saas_features.py:118:        result = verify_signature(payload, signature, timestamp, secret=secret)
./tests/test_saas_features.py:127:        secret = "test-secret-key"
./tests/test_saas_features.py:130:        result = verify_signature(payload, "v1=invalid", timestamp, secret=secret)
./tests/test_saas_features.py:139:        secret = "test-secret-key"
./tests/test_saas_features.py:142:        signature = compute_signature(payload, secret, timestamp)
./tests/test_saas_features.py:144:            payload, signature, timestamp, secret=secret, tolerance=300
./tests/test_saas_features.py:417:    def test_api_key_validation(self):
./tests/test_saas_features.py:425:        assert "password" in validator.INSECURE_API_KEYS
./tests/test_security_audit_fixes.py:237:        oidc_client_secret="test",
./tests/test_security_hardening.py:6:- Canary token detection
./tests/test_security_hardening.py:27:        mock_request.query_params = {"api_key": "secret_key_in_url"}
./tests/test_security_hardening.py:31:        result = _extract_key(mock_request, x_api_key=None)
./tests/test_security_hardening.py:43:        mock_request.query_params = {"key": "another_secret_key"}
./tests/test_security_hardening.py:46:        result = _extract_key(mock_request, x_api_key=None)
./tests/test_security_hardening.py:59:        result = _extract_key(mock_request, x_api_key="valid_header_key")
./tests/test_security_hardening.py:68:        mock_request.cookies = {"fg_api_key": "valid_cookie_key"}
./tests/test_security_hardening.py:70:        result = _extract_key(mock_request, x_api_key=None)
./tests/test_security_hardening.py:79:        mock_request.cookies = {"fg_api_key": "cookie_key"}
./tests/test_security_hardening.py:81:        result = _extract_key(mock_request, x_api_key="header_key")
./tests/test_security_hardening.py:86:    """Test canary token tripwire detection."""
./tests/test_security_middleware.py:198:        # Wait for refill (100 tokens/sec means 0.01s for 1 token)
./tests/test_sim_validator.py:150:    def test_guardian_secret_doctrine_applied(self):
./tests/test_sim_validator.py:153:            i for i in SIMULATION_INPUTS if i.name == "guardian_secret_classification"
./tests/test_ui_dashboards.py:157:    token = csrf.json()["csrf_token"]
./tests/test_ui_dashboards.py:160:        headers={"X-API-Key": key, "X-CSRF-Token": token},
./tests/test_ui_dashboards.py:220:    token = csrf.json()["csrf_token"]
./tests/test_ui_dashboards.py:224:        headers={"X-API-Key": key, "X-CSRF-Token": token},
./tools/tenants/__init__.py:8:    rotate_api_key,
./tools/tenants/__init__.py:11:    generate_api_key,
./tools/tenants/__main__.py:12:    rotate_api_key,
./tools/tenants/__main__.py:28:            "api_key": rec.api_key,
./tools/tenants/__main__.py:35:    rec = rotate_api_key(tenant_id=args.tenant_id)
./tools/tenants/__main__.py:39:            "api_key": rec.api_key,
./tools/tenants/registry.py:28:    api_key: str
./tools/tenants/registry.py:38:            api_key=d["api_key"],
./tools/tenants/registry.py:95:def generate_api_key() -> str:
./tools/tenants/registry.py:97:    import secrets
./tools/tenants/registry.py:99:    return secrets.token_urlsafe(32)
./tools/tenants/registry.py:105:    api_key: Optional[str] = None,
./tools/tenants/registry.py:110:      - if not: creates with generated api_key (or provided one)
./tools/tenants/registry.py:121:        api_key=api_key or generate_api_key(),
./tools/tenants/registry.py:132:def rotate_api_key(tenant_id: str) -> TenantRecord:
./tools/tenants/registry.py:138:    rec.api_key = generate_api_key()
